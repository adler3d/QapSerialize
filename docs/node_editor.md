отлично, тогда давай **одну миграцию**, но такую, чтобы:

* она **реальная**
* она **ломает модель**
* она **меняет смысл действий**
* и при этом **визуально сразу понятно, что произошло**

Я предложу одну, затем разложу:

* *до*
* *после*
* *почему это вау*
* *как показать*

---

## Миграция:

### **из “позиционного графа” > в “портовый граф (typed ports)”**

Это **идеальная** миграция для твоей истории с undo/redo.

---

## 1. До миграции (V0)

### Модель (упрощённо)

```cpp
class t_node{
  vec2d pos;
};

class t_link{
  TWeakPtr<t_node>a;
  TWeakPtr<t_node>b;
};
```

### Действия истории

```
AddNode
MoveNode
AddNode
MoveNode
ConnectNodes
MoveNode
```

Смысл:

* узел — точка
* связь — просто линия между двумя узлами
* всё просто и понятно

---

## 2. После миграции (V1)

Ты **меняешь смысл соединения**.

### Новая модель

```cpp
class t_port{
  vec2d offset;
  string type;
};

class t_node{
  vec2d pos;
  vector<t_port>ports;
};

class t_link{
  TWeakPtr<t_node>node;
  int port_id;
  TWeakPtr<t_node>node2;
  int port2_id;
};
```

То есть:

* связь теперь **не между узлами**
* а **между портами**
* порты имеют типы (`float`, `bool`, `flow`, etc)

?? Это **ломает старую модель** полностью.

---

## 3. Что делает миграция (ключевое)

При миграции ты:

1. Каждому старому узлу:

   * создаёшь **2 дефолтных порта**
   * `in` и `out`

2. Каждую старую связь:

   * переподключаешь:

     * `a > a.out`
     * `b > b.in`

Это **ручная миграция**, простая, но смысловая.

---

## 4. Почему это даёт максимальный эффект

### Потому что:

* **все старые действия остаются валидными**
* но **их эффект меняется**

Например:

### Было в истории:

```
MoveNode(A)
Connect(A,B)
MoveNode(B)
```

### После миграции:

* `MoveNode(A)` двигает **узел**
* но порт `out` у него имеет offset
* линия теперь идёт **не из центра**
* и визуально граф *меняется*

?? Читатель видит:

> *я не трогал историю, а результат другой*

---

## 5. Где тут магия undo/redo

Теперь твой сценарий вау:

1. Загружаем старый проект
2. Автомиграция в портовый граф
3. Откатываемся в историю **до Connect**
4. Вставляем новое действие:

```
AddPort(node=A,type="bool")
```

5. Жмём redo

?? И дальше:

* redo подключает **другой порт**
* линии идут иначе
* граф меняется **каскадно**

Это **идеальный пример “переигрывания истории”**.

---

## 6. Почему это невозможно показать без твоего подхода

В обычной системе:

* redo умер
* старые данные не совместимы
* история — не данные

У тебя:

* история — сериализуемая
* типы эволюционируют
* связи перепроживаются

Это **прямое доказательство ценности твоей системы**, не на словах.

---

## 7. Почему это красиво визуально

Ты получаешь:

* node graph (CTR ??)
* порты (всем понятно)
* линии, которые реально меняют геометрию

Скриншоты:

* *до*: линии центр-центр
* *после*: линии порт-порт

Разница видна даже **без текста**.

---

## 8. Почему именно эту миграцию я считаю лучшей

| Критерий          | Оценка |
| ----------------- | ------ |
| Реалистичность    | 10/10  |
| Ломает модель     | 10/10  |
| Визуальный эффект | 10/10  |
| Связь с undo/redo | 10/10  |
| Простота кода     | 7/10   |
| Статья объяснима  | 10/10  |

Это **идеальный кейс** для твоей темы.

---

## 9. Если хочешь следующий шаг

Могу:

* предложить **конкретные action-типы** (C++ структуры)
* придумать **одну “вставку в историю”, которая даёт максимально странный эффект**
* помочь сформулировать **ручную миграцию в коде (20–30 строк)**

Но в целом —
ты только что нашёл **свой главный пример для статьи**.
