# DESIGN.md

## QapSerialize — внутренняя архитектура и принципы

> Этот документ описывает архитектуру экспериментальной системы сериализации
> runtime-графов объектов с самоописанием типов.

Проект не является завершённым или production-ready.
Цель документа — зафиксировать архитектурные решения, инварианты и ограничения.

---

## 1. Базовая модель данных

### 1.1 Объектный граф

Система работает не с деревом, а с **произвольным графом объектов**, где:

* объекты могут ссылаться друг на друга
* допустимы циклы
* владение и ссылки разделены
* порядок создания объектов не имеет значения

Ключевая особенность:
**граф идентифицируется логически, а не через адреса памяти**.

---

## 2. Двойная система типов

Одна из ключевых идей системы — **разделение информации о типах** на два уровня:

### 2.1 Типы времени сохранения (Save-Time Types)

Используются для сериализации и миграции.

Содержат:

* описатели метатипов
* описатели пользовательских типов
* списки полей
* имена типов и полей
* логическую структуру данных

**Не содержат:**

* оффсеты в памяти
* ABI-зависимости
* фабрики
* код

Это декларативная модель структуры данных.

---

### 2.2 Типы времени выполнения (Run-Time Types)

Используются при работе программы.

Содержат:

* RTTI-объекты
* фабрики создания объектов
* информацию о наследовании
* оффсеты полей
* функции доступа

Это **исполняемая модель**, привязанная к конкретному бинарю.

---

### 2.3 Связь между уровнями

При загрузке файла:

* save-time описания типов сопоставляются с runtime-типами
* сопоставление идёт по **именам типов и полей**
* несовпадающие элементы обрабатываются декларативно:

  * лишние поля игнорируются
  * отсутствующие инициализируются дефолтами

Это ключевой механизм миграции форматов.

---

## 3. Самоописывающийся формат файла

Файл сериализации логически состоит из четырёх частей:

1. Описатели метатипов
2. Описатели всех используемых типов
3. Связь типов с runtime-реализациями
4. Payload — граф пользовательских данных

Файл можно анализировать **без исходного кода программы**.

---

## 4. Идентификация объектов

### 4.1 `TSelfPtr<T>`

Каждый сериализуемый объект может содержать `TSelfPtr`.

Назначение:

* уникальный логический идентификатор объекта
* используется при восстановлении ссылок
* не зависит от адреса в памяти

`TSelfPtr` не регистрирует объект в глобальной таблице, только локально(в TServerPtrSpace) во время сохранения.

---

### 4.2 `TWeakPtr<T>`

Слабая ссылка:

* хранит идентификатор целевого объекта
* разрешается после загрузки всего графа
* не влияет на владение
* переподключается к объекту при его переезде(std::move).
* автоматически отключается от объекта если тот удалился.

Позволяет строить циклы и перекрёстные ссылки.

---

### 4.3 `TAutoPtr<T>`

Владение объектом:

* используется как std::optional либо как полиморфный контейнер
* сериализует фактический runtime-тип
* отвечает за время жизни объекта

---

## 5. Полиморфизм

Полиморфные объекты сериализуются как:

* фактический тип объекта
* его поля

Тип **никогда не угадывается** при загрузке — он явно записан в данных.

---

## 6. Сериализация полей

Система сериализует поля:

* по именам, но имена храняться в отдельной секции и перечисляются всего один раз
* без привязки к layout памяти

Это обеспечивает устойчивость к:

* изменению порядка полей
* добавлению новых полей
* удалению старых полей

---

## 7. Текстовый формат

Текстовый формат — это:

* изоморфное представление бинарного
* инструмент отладки
* средство анализа и diff’ов

Он **не предназначен для ручного редактирования**
и не является DSL.

---

## 8. Эксперимент с `TFieldPtr` и причины отказа

`TFieldPtr` позволял ссылаться не на объект, а на конкретное поле.

Проблемы:

* идентификация поля по индексу
* зависимость от порядка полей
* хрупкость при миграции

В результате идея была признана тупиковой.

---

## 9. Переход к структурным путям (`TBranch`)

Вместо указателей на поля рассматривалась идея:

* хранить **структурный путь** к элементу
* валидация пути при загрузке
* возможность переинтерпретации при миграции

Это более устойчивый и декларативный подход.

---

## 10. Ограничения системы

Известные ограничения:

* MSVC only
* 32-bit
* высокая стоимость компиляции
* сложная кодовая база
* миграция типов с `TSelfPtr` и `TAutoPtr` проблемна
* удаление таких типов при миграции не всегда корректно

---

## 11. Основной вывод

Главный архитектурный вывод проекта:

> **Сериализация — это не про байты,
> а про сохранение инвариантов связей и типов.**

Система показала, что:

* графы принципиально сложнее деревьев
* миграция требует декларативной модели
* layout памяти — плохая точка привязки

---

## 12. Что бы делалось иначе сегодня

Если бы проект начинался сейчас:

* меньше шаблонов и макросов
* меньше магии
* больше декларативности
* стабильные текстовые идентификаторы
* явное разделение данных и кода

Но идеи:

* самоописания
* графов
* структурных путей

остаются актуальными.

Это хороший фундамент.
