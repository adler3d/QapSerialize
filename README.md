# QapSerialize

**Self-describing serialization of object graphs in C++ (experimental)**

> Экспериментальная система сериализации runtime-графов объектов
> с сохранением типов, ссылок и возможностью миграции между версиями структур.

⚠️ **Это не production-библиотека.**
Проект — исследовательский, замороженный, и публикуется как фиксация инженерного опыта.

---

## Зачем это вообще нужно

Система создавалась для решения нетиповой задачи:

* **сохранение всего состояния программы**, а не отдельных DTO
* **графы объектов**, а не деревья
* **циклы, полиморфизм, ссылки**
* **обновление бинарника без потери данных**
* **миграция данных между версиями структур**
* **продолжение работы без VM и без замедления в 10–50 раз**

Обычные форматы (JSON / protobuf / flatbuffers):

* хорошо работают с деревьями
* плохо работают с графами
* требуют жёсткой схемы и glue-кода
* не предназначены для миграции runtime-состояния

Этот проект — попытка пойти в другую сторону.

---

## Ключевая идея

Файл сохранения **самоописывающийся** и содержит:

1. Описание *метатипов* (описатели типов)
2. Описание всех используемых типов данных
3. Связь описаний типов с runtime-реализациями
4. Собственно данные (граф объектов)

При этом:

* бинарный и текстовый форматы **изоморфны**
* сериализация не зависит от layout памяти
* ссылки восстанавливаются по идентификаторам, а не по адресам

---

## Что именно сериализуется

✔️ **Состояние данных:**

* объекты
* графы
* циклы
* полиморфизм
* владение и слабые ссылки
* информация о типах

❌ **Не сериализуется:**

* стек вызовов
* PC / позиция выполнения
* состояние потоков
* GPU / network / OS-ресурсы

> Проще: система работает с **heap**, а не со **stack**.

---

## Основные типы ссылок

В проекте используются собственные ссылочные типы:

* **`TSelfPtr<T>`**
  Самоссылка — уникальный идентификатор объекта в графе

* **`TWeakPtr<T>`**
  Слабая ссылка на объект по его `TSelfPtr`

* **`TAutoPtr<T>`**
  Владение полиморфным объектом

* **`TFieldPtr`** *(устаревшая идея)*
  Ссылка на конкретное поле объекта (оказалась слишком хрупкой)

Позже от `TFieldPtr` был сделан шаг в сторону **структурных путей (TBranch)**.

---

## Текстовый формат

Помимо бинарного файла, система умеет сохранять **текстовый proto-дамп**.

Он предназначен для:

* отладки
* анализа состояния
* diff’ов между версиями
* понимания структуры данных

❗ Текстовый формат **не предназначен для ручного редактирования**
и ближе к IR, чем к DSL.

---

## Миграция форматов (что реально работает)

Система поддерживает загрузку старых файлов при изменении структур:

* изменение порядка полей
* добавление новых полей
* удаление полей

Почему это работает:

* сопоставление идёт по **именам полей**
* layout памяти не используется
* лишние поля игнорируются
* отсутствующие получают дефолты

⚠️ **Ограничения:**

Надёжно мигрируются только «тупые» типы:

* встроенные типы
* строки
* структуры
* векторы
* их комбинации

Удаление типов с `TSelfPtr`, `TAutoPtr` при миграции —
**проблемное место системы**.

---

## Статус проекта

* проект написан **более 10 лет назад**
* активно использует макросы и шаблоны
* **MSVC only**
* **32-bit**
* заморожен из-за времени компиляции и сложности поддержки

Проект публикуется **как исследование**, а не как готовое решение.

---

## Связанные материалы

* Статья на Хабре:
  [Как сериализовать всё состояние C++-программы и пережить обновление бинарника](https://habr.com/ru/articles/976426/)
  (с примерами, разбором и ограничениями)

* Пример миграционного теста:
  `CommonUnit.cpp`

---

## Итог

Этот репозиторий — не ответ «как правильно».

Это ответ на вопрос:

> *А что будет, если попытаться сериализовать не данные,
> а **состояние сложной программы целиком**?*

Если вам интересны:

* графы данных
* долгоживущие программы
* миграция runtime-состояния
* самоописание форматов

— возможно, здесь есть идеи, которые стоит забрать с собой.
